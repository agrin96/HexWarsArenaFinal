//
//  BoardTileManager.swift
//  HexWars
//
//  Created by Aleksandr Grin on 8/12/17.
//  Copyright Â© 2017 AleksandrGrin. All rights reserved.
//

import Foundation
import SpriteKit
import UIKit
import CoreImage

//Define the name of the adjacent tile directions. Use an array of directions to indicate which
// edges tiles have adjacency
enum TileAdjacencyDirections:Int{
    case E = 0
    case NE = 1
    case NW
    case W
    case SW
    case SE
}

//These are the coordinate transforms to find neighboring tiles for a given tile.
var oddR_Directions:Array<Array<(dCol: Int,dRow: Int)>> = [
    [(1,0), (0,1), (-1,1), (-1,0), (-1,-1), (0,-1)],
    [(1,0), (1,1), ( 0,1), (-1,0), ( 0,-1), (1,-1)]
]

class BoardTileManager:NSObject, NSCoding {
    var mainBoardMap:SKTileMapNode?
    var tileSelectionBoardMap:SKTileMapNode?        //At this tilemap we set a highlight, to indicate selected tile.
    var tileWallingBoardMap:SKTileMapNode?          //This tilemap stores the walls surrounding tiles.
    var tileWallingTextures:TileWallTextures?

    var level1_Group:SKTileGroup?
    var level2_Group:SKTileGroup?
    var level3_Group:SKTileGroup?
    var crownGroup:SKTileGroup?
    var unclaimedGroup:SKTileGroup?
    var drawContext:CIContext?

    var currentTileToOperateOn:CGPoint?
    var currentPlayerPiece:String?

    //Holds the gameModel that is updated both manually and by the AI
    weak var gameModel:GameModel?

    override init(){
        super.init()
    }

    func encode(with aCoder: NSCoder) {
        aCoder.encode(self.mainBoardMap!, forKey: "BoardTileManager_mainBoardMap")
        aCoder.encode(self.tileSelectionBoardMap!, forKey: "BoardTileManager_tileSelectionBoardMap")
        aCoder.encode(self.tileWallingBoardMap!, forKey: "BoardTileManager_tileWallingBoardMap")

        aCoder.encode(self.tileWallingTextures!.wallType.rawValue, forKey: "BoardTileManeger_tileWallingTextures")

        aCoder.encode(self.level1_Group!, forKey: "BoardTileManager_level1Group")
        aCoder.encode(self.level2_Group!, forKey: "BoardTileManager_level2Group")
        aCoder.encode(self.level3_Group!, forKey: "BoardTileManager_level3Group")
        aCoder.encode(self.crownGroup!, forKey: "BoardTileManager_crownGroup")
        aCoder.encode(self.unclaimedGroup!, forKey: "BoardTileManager_unclaimedGroup")
        //Dont have to save drawContext it can jsut be reinitialized when needed

        aCoder.encode(self.currentTileToOperateOn, forKey: "BoardTileManager_currentTileToOperateOn")
        aCoder.encode(self.currentPlayerPiece!, forKey: "BoardTileManager_currentPLayerPiece")
    }

    required init?(coder aDecoder: NSCoder) {
        super.init()
        let data = aDecoder.decodeInteger(forKey: "BoardTileManeger_tileWallingTextures")
        self.tileWallingTextures = TileWallTextures(type: WallType(rawValue: data)!)

        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_mainBoardMap") as? SKTileMapNode {
            self.mainBoardMap = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_tileSelectionBoardMap") as? SKTileMapNode {
            self.tileSelectionBoardMap = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_tileWallingBoardMap") as? SKTileMapNode {
            self.tileWallingBoardMap = data
            self.tileWallingBoardMap!.tileSet.tileGroups = []
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_level1Group") as? SKTileGroup{
            self.level1_Group = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_level2Group") as? SKTileGroup{
            self.level2_Group = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_level3Group") as? SKTileGroup{
            self.level3_Group = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_crownGroup") as? SKTileGroup {
            self.crownGroup = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_unclaimedGroup") as? SKTileGroup{
            self.unclaimedGroup = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_currentTileToOperateOn") as? CGPoint{
            self.currentTileToOperateOn = data
        }
        if let data = aDecoder.decodeObject(forKey: "BoardTileManager_currentPLayerPiece") as? String {
            self.currentPlayerPiece = data
        }
        //self.updateTileWalls(for: nil)
    }

    ///********************** Main Board Setup and Update Functions *****************///

    //Create a TileMap from a 2D array generated by the map model class.
    func initializeBoardMapFor(model:Array<Array<TileTypes>>, mapDescription: GameMap){
        if mainBoardMap == nil{
            let tileSet = SKTileSet(named: "NewTileSet")
            tileSet?.type = .hexagonalPointy

            mainBoardMap = SKTileMapNode(tileSet: tileSet!, columns: (mapDescription.mapBounds?.columns)!,
                    rows: (mapDescription.mapBounds?.rows)!,
                    tileSize: CGSize(width: 66, height: 70))
            mainBoardMap?.anchorPoint = CGPoint(x: 0.5, y: 0.5)
            mainBoardMap?.zPosition = 0
            mainBoardMap?.position = CGPoint(x: 0, y: 100)
            extractTileGroups(from: tileSet!)

            for row in 0..<(mapDescription.mapBounds?.rows)! {
                for col in 0..<(mapDescription.mapBounds?.columns)! {
                    let rowReal = (mapDescription.mapBounds?.rows)! - 1 - row
                    if model[row][col] == .neutral {
                        //Rows have to be flipped because the tilemap coordinate systems start at the bottom
                        // while array indexing starts at the top.
                        mainBoardMap?.setTileGroup(unclaimedGroup, forColumn: col, row: rowReal)
                    }else if model[row][col] == .crown {
                        mainBoardMap?.setTileGroup(crownGroup, forColumn: col, row: rowReal)
                    }else if model[row][col] == .level1 {
                        let tileDef = level1_Group!.rules[0].tileDefinitions.first(where: {
                            if $0.name != nil { return $0.name!.contains(GameState.sharedInstance().mainPlayerOptions!.chosenGameTheme!.themeName())
                            }else{
                                return false
                            }})
                        mainBoardMap?.setTileGroup(level1_Group!, andTileDefinition: tileDef!, forColumn: col, row: rowReal)
                    }else if model[row][col] == .level2 {
                        let tileDef = level2_Group!.rules[0].tileDefinitions.first(where: {
                            if $0.name != nil { return $0.name!.contains(GameState.sharedInstance().mainPlayerOptions!.chosenGameTheme!.themeName())
                            }else{
                                return false
                            }})
                        mainBoardMap?.setTileGroup(level2_Group!, andTileDefinition: tileDef!, forColumn: col, row: rowReal)
                    }else if model[row][col] == .level3 {
                        let tileDef = level3_Group!.rules[0].tileDefinitions.first(where: {
                            if $0.name != nil { return $0.name!.contains(GameState.sharedInstance().mainPlayerOptions!.chosenGameTheme!.themeName())
                            }else{
                                return false
                            }})
                        mainBoardMap?.setTileGroup(level3_Group!, andTileDefinition: tileDef!, forColumn: col, row: rowReal)
                    }
                }
            }

            if tileSelectionBoardMap == nil {
                tileSelectionBoardMap = SKTileMapNode(tileSet: tileSet!,
                        columns: mainBoardMap!.numberOfColumns,
                        rows: mainBoardMap!.numberOfRows,
                        tileSize: CGSize(width: 66, height: 70))
                tileSelectionBoardMap?.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                tileSelectionBoardMap?.zPosition = 1
                tileSelectionBoardMap?.position = mainBoardMap!.position
                tileSelectionBoardMap?.alpha = 1.0
            }

            if tileWallingBoardMap == nil {
                let wallSet = SKTileSet(tileGroups: [])
                wallSet.type = .hexagonalPointy
                tileWallingBoardMap = SKTileMapNode(tileSet: wallSet,
                        columns: mainBoardMap!.numberOfColumns,
                        rows: mainBoardMap!.numberOfRows,
                        tileSize: CGSize(width: 66, height: 70))
                tileWallingBoardMap?.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                tileWallingBoardMap?.zPosition = 3
                tileWallingBoardMap?.position = mainBoardMap!.position
                tileWallingBoardMap?.alpha = 1.0
            }


        }
    }

    //After the setup of the map and players is done, we condense that information into a TileInformation Array
    // and return that so that the gameModel can be initialized.
    func initializeGameModel() -> [[TileInformation]]{
        var tileInfo:[[TileInformation]] = TileInformation.init2DCollection(rows: self.mainBoardMap!.numberOfRows, columns: self.mainBoardMap!.numberOfColumns)
        for row in 0..<self.mainBoardMap!.numberOfRows {
            for col in 0..<self.mainBoardMap!.numberOfColumns {
                if self.mainBoardMap!.tileGroup(atColumn: col, row: row) != nil {
                    //If the tile exists then we gather its information
                    let name:String = self.mainBoardMap!.tileGroup(atColumn: col, row: row)!.name!
                    if name.contains("Player"){
                        if let id = Int("\(name.last!)"){
                            for player in (self.mainBoardMap!.scene as! GameScene).gamePlayers! {
                                if player.playerId == id {
                                    tileInfo[row][col].owningPlayer = player
                                }
                            }
                        }
                    }

                    let tileName:TileTypes = {()->TileTypes in
                        if name.contains(level1_Group!.name!){ return TileTypes.level1 }
                        if name.contains(level2_Group!.name!){ return TileTypes.level2 }
                        if name.contains(level3_Group!.name!){ return TileTypes.level3 }
                        if name.contains(crownGroup!.name!){ return TileTypes.crown }
                        if name.contains(unclaimedGroup!.name!){ return TileTypes.neutral }
                        return .empty
                    }()

                    tileInfo[row][col].tileType = tileName
                }else{
                    //If the tile doesn't exist we set nil paramaters.
                    tileInfo[row][col].owningPlayer = nil
                    tileInfo[row][col].tileType = .empty
                }

            }
        }
        var output = ""
        for i in 0..<tileInfo.count {
            for j in 0..<tileInfo[i].count {
                let realRow = tileInfo.count - i - 1
                if j % tileInfo[0].count == 0 {
                    output += "\n"
                }
                if tileInfo[realRow][j].owningPlayer != nil {
                    output += "[\(tileInfo[realRow][j].owningPlayer!.playerId)]"
                }else{
                    output += "[0]"
                }
            }
        }
        return tileInfo
    }

    //On initialization we store tilegroups as class members for more convenient access.
    private func extractTileGroups(from tileSet: SKTileSet){
        let tileGroups = tileSet.tileGroups

        unclaimedGroup = tileGroups.first(where: {$0.name == "Unclaimed"})
        level1_Group = tileGroups.first(where: {$0.name == "Level1"})
        level2_Group = tileGroups.first(where: {$0.name == "Level2"})
        level3_Group = tileGroups.first(where: {$0.name == "Level3"})
        crownGroup = tileGroups.first(where: {$0.name == "Crown"})

        if unclaimedGroup == nil || level2_Group == nil || level1_Group == nil || level3_Group == nil || crownGroup == nil {
            print("Failed to INIT TileGroups")
        }
    }

    //On initialization we need to recolor our existing tiles to suit the player colors and add them
    // to the roster of tiles available to the tileSet. This is done because individual tiles cannot
    // for some reason be changed. A solution with TileDefinition variatons was tried but failed.
    func setupColorationTileGroups(for players: Array<Player>){
        var newGroups:Array<SKTileGroup> = []
        for player in players {
            for group in mainBoardMap!.tileSet.tileGroups {
                let tiles = group.rules[0].tileDefinitions.filter({if $0.name != nil { return true }else{return false}})

                    for tile in tiles {
                        if tile.name!.contains(player.gameTheme!.themeName()) || tile.name!.contains("Crown"){
                            if tile.name != "EmptyHexDarkSelection" {
                                //All other dark tiles set here
                                let coloredDefinition = colorizeTile(tile: tile, into: player.color!)
                                let newGroup = SKTileGroup(tileDefinition: coloredDefinition)

                                newGroup.name = group.name! + "Player" + String(player.playerId)
                                //print(newGroup.name)
                                if mainBoardMap!.tileSet.tileGroups.contains(newGroup) == false{
                                    newGroups.append(newGroup)
                                }
                            }
                        }
                }
                if let tile = group.rules[0].tileDefinitions.first(where: {if $0.name != nil { return $0.name!.contains("Selection")}else{return false}}){
                    if tile.name == "EmptyHexSelection" {

                        //We need one tile for selection highlighting.
                        let newDefinition = SKTileDefinition(texture: tile.textures[0])
                        let newGroup = SKTileGroup(tileDefinition: newDefinition)
                        newGroup.name = "UnclaimedDark"

                        if !mainBoardMap!.tileSet.tileGroups.contains(newGroup){
                            newGroups.append(newGroup)
                        }
                    }
                }
            }
        }
        for group in newGroups{
            mainBoardMap!.tileSet.tileGroups.append(group)
        }
        //setupCounterTileGroups(for: players)

        updateTileColoring(for: players)
    }

    //Goes through player data to check all locations of player tiles and color them to the correct color on startup.
    func updateTileColoring(for players: Array<Player>){
        for player in players{
            if player.crown_Locations != nil{
                changeTileGroupToNewColor(for: player.crown_Locations!, group: crownGroup!, playerID: player.playerId)
            }
            if player.level1_Locations != nil{
                changeTileGroupToNewColor(for: player.level1_Locations!, group: level1_Group!, playerID: player.playerId)
            }
            if player.level2_Locations != nil{
                changeTileGroupToNewColor(for: player.level2_Locations!, group: level2_Group!, playerID: player.playerId)
            }
            if player.level3_Locations != nil{
                changeTileGroupToNewColor(for: player.level3_Locations!, group: level3_Group!, playerID: player.playerId)
            }
        }
    }

    //Sets the player color on a set of tiles using coordinates.
    private func changeTileGroupToNewColor(for playerTiles: [CGPoint], group: SKTileGroup, playerID:Int){
        for tile in playerTiles {
            let tileSet = mainBoardMap!.tileSet.tileGroups
            let group = tileSet.first(where: {$0.name == group.name! + "Player" + String(playerID)})
            mainBoardMap!.setTileGroup(group, forColumn: Int(tile.x), row: Int(tile.y))
        }
    }

    //Takes an SKTileDefinition, extracts the texture, applies a monochrome coloring filter and returns a new
    // tile definition to be used in a new group. When attempting to use the tiledefinition directly it fails.
    private func colorizeTile(tile: SKTileDefinition, into color: UIColor) -> SKTileDefinition{
        if drawContext == nil{
            drawContext = CIContext()
        }

        let texture = tile.textures[0]

        let colorationFilter = CIFilter(name: "CIColorMonochrome")
        colorationFilter!.setValue(CIImage(cgImage: texture.cgImage()), forKey: kCIInputImageKey)
        colorationFilter!.setValue(CIColor(cgColor: color.cgColor), forKey: "inputColor")
        colorationFilter!.setValue(0.7, forKey: "inputIntensity")

        let result = colorationFilter!.outputImage!
        let output = drawContext!.createCGImage(result, from: result.extent)
        let coloredTexture = SKTexture(cgImage: output!)

        let newDefinition = SKTileDefinition(texture: texture)
        newDefinition.textures[0] = coloredTexture
        newDefinition.name = "meow"

        return newDefinition
    }

    //Tile sets are persistant even after unwining a view controller. So we must reset player tile groups every game.
    func resetColorationTileGroups(){
        let filteredTileset = self.mainBoardMap!.tileSet.tileGroups.filter({ $0.name!.contains("Player") == false})
        self.mainBoardMap!.tileSet.tileGroups = filteredTileset
    }

    //This makes sure we have the correct player piece name to use in the tile construction menu
    func getCurrentPlayerPiece(){
        var playerPieceName = ""
        switch (self.mainBoardMap!.scene as! GameScene).currentActivePlayer!.gameTheme! {
        case .medieval:
            playerPieceName = "Medieval_Counter"
            break
        case .scifi:
            playerPieceName = "Scifi_Counter"
            break
        case .modern:
            playerPieceName = "Modern_Counter"
            break
        }
        self.currentPlayerPiece = playerPieceName
    }


    ///***************** Tile Construction Functions ***********************///

    func handleTileTap(_ sender: UITapGestureRecognizer, player: Player) -> Bool{

        if let gameScene = mainBoardMap!.parent?.scene {

            let rawLocation = sender.location(in: gameScene.view!)
            let location = gameScene.convertPoint(fromView: rawLocation)
            let newLoc = gameScene.convert(location, to: mainBoardMap!)

            if mainBoardMap != nil{
                let row = mainBoardMap!.tileRowIndex(fromPosition: newLoc)
                let col = mainBoardMap!.tileColumnIndex(fromPosition: newLoc)

                //Make sure to unhighlight the previous selection.
                if currentTileToOperateOn != nil{
                    if tileSelectionBoardMap!.tileGroup(atColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y)) != nil {
                        if tileSelectionBoardMap!.tileGroup(atColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))!.name == "UnclaimedDark"{
                            unhighlightSelectedTile()
                        }
                    }
                }

                debugShowTileLayerInfo(for: CGPoint(x: col, y: row))
                if self.gameModel!.isValidBuildLocation(of: player, for: CGPoint(x: col, y: row)){
                    if let tile = mainBoardMap!.tileGroup(atColumn: col, row: row) {
                        if tile.name == "Unclaimed" ||
                                   (tile.name!.contains("Player") == true && tile.name!.contains("Player\(player.playerId)") == false) ||
                                   (tile.name! == "Crown" && tile.name!.contains("Player") == false) ||
                                           (tile.name! == "Level1" && tile.name!.contains("Player") == false) ||
                                           (tile.name! == "Level2" && tile.name!.contains("Player") == false) ||
                                           (tile.name! == "Level3" && tile.name!.contains("Player") == false) {

                            //Since this is a valid tile we store it
                            currentTileToOperateOn = CGPoint(x: col, y: row)
                            highlightSelctedTile(location: currentTileToOperateOn!)
                            (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.updateBuildSymbolCount(for: player)
                            return true
                        }
                    }
                }
            }
        }
        return false
    }

    func handleBuildingOnTile(tileToBuild: SKTileGroup, currentPlayer:Player) {
        //We use this to figure out which player's walls and adjacency we should update for each move. We Only update adjacency when tile ownership changes.
        var playersToUpdateWalls:[Player] = [currentPlayer]

        if currentTileToOperateOn != nil {
            if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType != .empty {
                if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer != nil{

                    if tileToBuild.name! == "\(self.currentPlayerPiece!)Player\(currentPlayer.playerId)" {
                        if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .level1 {
                            //Enemy Level1 tile.
                            if currentPlayer.availableCounters! > 0{
                                currentPlayer.availableCounters! -= 1
                                //Tile ownership is changing so we need to update the player's walls.
                                playersToUpdateWalls.append(self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!)
                                //Update Player Data
                                self.gameModel!.removeTileFromPlayer(player: self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!, tile: .level1, location: currentTileToOperateOn!)
                                self.gameModel!.addTilesToPlayer(player: currentPlayer, tile: .counter, location: currentTileToOperateOn!)

                                self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .counter
                                self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer = currentPlayer
                                self.mainBoardMap!.setTileGroup(tileToBuild, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                                unhighlightSelectedTile()
                            }else{
                                if currentPlayer.isPlayerHuman == true{
                                    (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                                }
                            }
                        }else if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .level2 {
                            //Enemy Level2 Tile, we demote to level1
                            if currentPlayer.availableCounters! > 0{
                                currentPlayer.availableCounters! -= 1
                                let name = (mainBoardMap!.tileGroup(atColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))?.name)
                                let playerNum = name!.last
                                var tileName:String = "\(level1_Group!.name!)Player"
                                tileName.append(playerNum!)

                                self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .level1
                                let demotedFarm = mainBoardMap!.tileSet.tileGroups.first(where: {$0.name! == tileName})
                                self.mainBoardMap!.setTileGroup(demotedFarm!, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                                unhighlightSelectedTile()

                                //Update Player Data
                                self.gameModel!.removeTileFromPlayer(player: self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!, tile: .level2, location: currentTileToOperateOn!)
                                self.gameModel!.addTilesToPlayer(player: self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!, tile: .level1, location: currentTileToOperateOn!)
                            }else{
                                if currentPlayer.isPlayerHuman == true{
                                    (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                                }
                            }
                        }else if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .level3 {
                            //Enemy Level3 Tile, we demote to Level2
                            if currentPlayer.availableCounters! > 0{
                                currentPlayer.availableCounters! -= 1
                                let name = (mainBoardMap!.tileGroup(atColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))?.name)
                                let playerNum = name!.last
                                var tileName:String = "\(level2_Group!.name!)Player"
                                tileName.append(playerNum!)

                                self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .level2
                                let demotedIndustry = mainBoardMap!.tileSet.tileGroups.first(where: {$0.name! == tileName})
                                mainBoardMap!.setTileGroup(demotedIndustry!, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                                unhighlightSelectedTile()

                                //Update Player Data
                                self.gameModel!.removeTileFromPlayer(player: self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!, tile: .level3, location: currentTileToOperateOn!)
                                self.gameModel!.addTilesToPlayer(player: self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!, tile: .level2, location: currentTileToOperateOn!)
                            }else{
                                if currentPlayer.isPlayerHuman == true{
                                    (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                                }
                            }
                        }else if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .crown {
                            //An enemy Crown Tile either loses health or is totally destroyed
                            if currentPlayer.availableCounters! > 0 {
                                currentPlayer.availableCounters! -= 1
                                let owner = self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!
                                if owner.crownHealth! > 1 {
                                    owner.crownHealth! -= 1
                                    self.updateCrownHealthLabel()
                                    unhighlightSelectedTile()
                                }else{
                                    //Tile ownership is changing so we need to update the player's walls.
                                    playersToUpdateWalls.append(owner)
                                    owner.crownHealth! -= 1

                                    //Update PlayerData
                                    self.gameModel!.removeTileFromPlayer(player: self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer!, tile: .crown, location: currentTileToOperateOn!)
                                    self.gameModel!.addTilesToPlayer(player: currentPlayer, tile: .counter, location: currentTileToOperateOn!)

                                    self.updateCrownHealthLabel()
                                    self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .counter
                                    self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer = currentPlayer
                                    mainBoardMap!.setTileGroup(tileToBuild, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                                    unhighlightSelectedTile()
                                }

                            }else{
                                if currentPlayer.isPlayerHuman == true{
                                    (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                                }
                            }
                        }
                    }
                }else{
                    //Neutral Tiles
                    if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .level1 {
                        //Capture a neutral Level1 and make it ours!
                        if currentPlayer.availableCounters! > 0 {
                            currentPlayer.availableCounters! -= 1

                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .level1
                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer = currentPlayer
                            let playerPiece = mainBoardMap!.tileSet.tileGroups.first(where: { $0.name! == "Level1Player\(currentPlayer.playerId)" })
                            mainBoardMap!.setTileGroup(playerPiece!, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))

                            //Update PlayerData
                            self.gameModel!.addTilesToPlayer(player: currentPlayer, tile: .level1, location: currentTileToOperateOn!)
                            unhighlightSelectedTile()
                        } else {
                            if currentPlayer.isPlayerHuman == true{
                                (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                            }
                        }
                    }else if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .level2 {
                        //Capture a neutral Level2 and make it ours!
                        if currentPlayer.availableCounters! > 0 {
                            currentPlayer.availableCounters! -= 1

                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .level2
                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer = currentPlayer

                            let playerPiece = mainBoardMap!.tileSet.tileGroups.first(where: { $0.name! == "Level2Player\(currentPlayer.playerId)" })
                            mainBoardMap!.setTileGroup(playerPiece!, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                            unhighlightSelectedTile()

                            //Update PlayerData
                            self.gameModel!.addTilesToPlayer(player: currentPlayer, tile: .level2, location: currentTileToOperateOn!)
                        } else {
                            if currentPlayer.isPlayerHuman == true{
                                (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                            }
                        }
                    }else if self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType == .level3 {
                        //Capture a neutral Level3 and make it ours!
                        if currentPlayer.availableCounters! > 0 {
                            currentPlayer.availableCounters! -= 1

                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .level3
                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer = currentPlayer
                            let playerCrown = mainBoardMap!.tileSet.tileGroups.first(where: { $0.name! == "Level3Player\(currentPlayer.playerId)" })
                            mainBoardMap!.setTileGroup(playerCrown!, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                            unhighlightSelectedTile()

                            //Update PlayerData
                            self.gameModel!.addTilesToPlayer(player: currentPlayer, tile: .level3, location: currentTileToOperateOn!)
                        }else{
                            if currentPlayer.isPlayerHuman == true{
                                (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                            }
                        }
                    }else{
                        if currentPlayer.availableCounters! > 0 {
                            currentPlayer.availableCounters! -= 1
                            //Unclaimed Tile

                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].tileType = .counter
                            self.gameModel!.gameMapModel![Int(self.currentTileToOperateOn!.y)][Int(self.currentTileToOperateOn!.x)].owningPlayer = currentPlayer

                            mainBoardMap!.setTileGroup(tileToBuild, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                            unhighlightSelectedTile()

                            //Update PlayerData
                            self.gameModel!.addTilesToPlayer(player: currentPlayer, tile: .counter, location: currentTileToOperateOn!)
                        }else{
                            if currentPlayer.isPlayerHuman == true{
                                (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.displayGameNotification(text: "Insufficient Counters", textColor: nil, completion: {})
                            }
                        }
                    }
                }

                //Reset to prevent repettive tile taps
                self.unhighlightSelectedTile()
                self.currentTileToOperateOn = nil

                if (self.gameModel!.activePlayer! as! Player).isPlayerHuman == true {
                    (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.updateIndicatorLabels(for: self.gameModel!.activePlayer! as! Player)
                    (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.updateBuildSymbolCount(for: currentPlayer)
                }
                (self.mainBoardMap!.scene as! GameScene).checkForPlayerLosing()

                DispatchQueue.global().sync { [unowned self] in
                    self.updateTileWalls(for: playersToUpdateWalls)   //FindAdjacencyGroups() is called inside here as necessary for the following destroy() function.
                    self.destroyNonAdjacentTiles()
                    self.resetTileWallLayer()
                }
            }
        }
    }

    //Cycles through available tile upgrades of the player and executes them.
    func upgradeExistingPlayerTiles(for player:Player){
        var groupToPlace:SKTileGroup!

        if player.availableLevel1! > 0{
            groupToPlace = self.mainBoardMap!.tileSet.tileGroups.first(where: {$0.name! == "\(self.level1_Group!.name!)Player\(player.playerId)"})!
        }
        let counterLocations = player.counter_Locations!
        for tile in counterLocations {
            if player.availableLevel1! > 0 {
                self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileType = .level1

                self.gameModel!.addTilesToPlayer(player: player, tile: .level1, location: tile)
                self.gameModel!.removeTileFromPlayer(player: player, tile: .counter, location: tile)
                self.mainBoardMap!.setTileGroup(groupToPlace, forColumn: Int(tile.x), row: Int(tile.y))
                player.availableLevel1! -= 1
            }
        }

        if player.availableLevel2! > 0{
            groupToPlace = self.mainBoardMap!.tileSet.tileGroups.first(where: {$0.name! == "\(self.level2_Group!.name!)Player\(player.playerId)"})!
        }
        let level1Locations = player.level1_Locations!
        for tile in level1Locations {
            if player.availableLevel2! > 0 {
                self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileType = .level2

                self.gameModel!.addTilesToPlayer(player: player, tile: .level2, location: tile)
                self.gameModel!.removeTileFromPlayer(player: player, tile: .level1, location: tile)
                self.mainBoardMap!.setTileGroup(groupToPlace, forColumn: Int(tile.x), row: Int(tile.y))
                player.availableLevel2! -= 1
            }
        }

        if player.availableLevel3! > 0{
            groupToPlace = self.mainBoardMap!.tileSet.tileGroups.first(where: {$0.name! == "\(self.level3_Group!.name!)Player\(player.playerId)"})!
        }
        let level2locations = player.level2_Locations!
        for tile in level2locations {
            if player.availableLevel3! > 0 {
                self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileType = .level3

                self.gameModel!.addTilesToPlayer(player: player, tile: .level3, location: tile)
                self.gameModel!.removeTileFromPlayer(player: player, tile: .level2, location: tile)
                self.mainBoardMap!.setTileGroup(groupToPlace, forColumn: Int(tile.x), row: Int(tile.y))
                player.availableLevel3! -= 1
            }
        }
    }

    ///***************** Tile Adjacency Functions *************************///

    //Using the adjacency matrix created by the findAdjacentGroups() function, we can eliminate tiles that are cut off
    // from a player's crown tile.
    func destroyNonAdjacentTiles(){
        for row in 0..<mainBoardMap!.numberOfRows {
            for col in 0..<mainBoardMap!.numberOfColumns {
                if self.gameModel!.gameMapModel![row][col].tileType != .empty {
                    if self.gameModel!.gameMapModel![row][col].owningPlayer != nil  {
                        if self.gameModel!.gameMapModel![Int(row)][Int(col)].isTileAdjacent == 0 {
                            //For the AI we need to manually update the tile ownership. In this case we remove.
                            let player = self.gameModel!.gameMapModel![row][col].owningPlayer!
                            let tileType = self.gameModel!.gameMapModel![row][col].tileType!
                            self.gameModel!.removeTileFromPlayer(player: player, tile: tileType, location: CGPoint(x: col, y: row))

                            self.mainBoardMap!.setTileGroup(unclaimedGroup!, forColumn: Int(col), row: Int(row))
                            self.gameModel!.gameMapModel![row][col].tileType = .neutral
                            self.gameModel!.gameMapModel![row][col].owningPlayer = nil
                        }
                    }
                }
            }
        }
    }

    //Shows a printout of 1s wherever a tile is marked adjacent and 0 where its not.
    private func printAdjacentTileDebug(){
        var display:String = ""
        if self.gameModel!.gameMapModel != nil{
            for i in 0..<self.gameModel!.gameMapModel!.count {
                for j in 0..<self.gameModel!.gameMapModel![0].count {
                    if j % self.gameModel!.gameMapModel![0].count == 0 {
                        display += "\n"
                    }
                    let realRow = self.gameModel!.gameMapModel!.count - i - 1
                    var adjacencyValue = 0
                    if self.gameModel!.gameMapModel![realRow][j].isTileAdjacent! != 0 { adjacencyValue = self.gameModel!.gameMapModel![realRow][j].isTileAdjacent! }
                    display += "[\(adjacencyValue)]"
                }
            }
        }
        print(display)
    }


    ///***************** Effects Board Map Functions **********************///

    //Uses the effects tile map layer to set a gray tile which acts as a highlight or indicator of where the user has selected
    func highlightSelctedTile(location: CGPoint){
        if mainBoardMap != nil{
            let tileSet = mainBoardMap!.tileSet.tileGroups
            let highlightGroup = tileSet.first(where: {$0.name == "UnclaimedDark"})
            tileSelectionBoardMap!.setTileGroup(highlightGroup!, forColumn: Int(location.x), row: Int(location.y))
        }
    }

    func unhighlightSelectedTile(){
        if mainBoardMap != nil && currentTileToOperateOn != nil {
            if tileSelectionBoardMap!.tileGroup(atColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y)) != nil {
                if tileSelectionBoardMap!.tileGroup(atColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))!.name == "UnclaimedDark"{
                    tileSelectionBoardMap!.setTileGroup(nil, forColumn: Int(currentTileToOperateOn!.x), row: Int(currentTileToOperateOn!.y))
                }
            }
        }
    }

    func createCrownHealth(){
        for player in self.gameModel!.players! as! [Player]{
            for crown in player.crown_Locations!{
                //let realRow = self.mainBoardMap!.numberOfRows - Int(crown.y) - 1
                let position = self.mainBoardMap!.centerOfTile(atColumn: Int(crown.x), row: Int(crown.y))
                let label = self.createHealthLabel(for: player.crownHealth!)
                label.name = "crownHealth\(player.playerId)"
                label.position = position
                label.position.y -= 7
                label.position.x += 2
                label.zPosition = 5
                self.mainBoardMap!.addChild(label)
            }
        }
    }

    private func createHealthLabel(for health:Int) -> SKLabelNode{
        let label = SKLabelNode(text: String(health))
        label.fontColor = .black
        label.fontSize = 16
        label.fontName = "Arial-BoldMT"
        label.zPosition = 21
        label.alpha = 1.0
        label.horizontalAlignmentMode = .center
        label.verticalAlignmentMode = .center
        label.isHidden = false

        return label
    }

    func updateCrownHealthLabel(){
        for player in self.gameModel!.players! as! [Player]{
            if let indicator = (self.mainBoardMap!.scene as! GameScene).gameCameraAndUI!.childNode(withName: "//crownCountLabel") as? SKLabelNode{
                indicator.text = "Crown: \(player.crownHealth!)"
            }
            if let label = self.mainBoardMap!.childNode(withName: "crownHealth\(player.playerId)") as? SKLabelNode{
                label.text = "\(player.crownHealth!)"
                if player.crownHealth! == 0 {
                    label.removeFromParent()
                }
            }
        }
    }

    ///******************* Tile Walling Functions ************************///

    //makes an easily accessible texture Atlas
    func initTileWallTextures(for type: WallType){
        self.tileWallingTextures = TileWallTextures(type: type)
    }

    //This function creates a set of textures out of the 6 wall directions. It uses the adjacency directions from the
    // findAdjacentGroups() function per tile to determine which of the 6 wall sections should be present in the texture
    // If the texture is already present then it simply returns nil
    private func createTileGroupOfWalls(for directions:Array<TileAdjacencyDirections>, player: Player) -> SKTileGroup? {
        var dynamicName = ""
        let allDirections:[TileAdjacencyDirections] = [.E, .NE, .NW, .W, .SW, .SE]

        //We need to first create the dynamic name and see if we already have this wall combination.
        for direction in allDirections {
            if directions.contains(direction) == false {
                switch direction {
                case .E:
                    dynamicName += "1"
                    break
                case .NE:
                    dynamicName += "2"
                    break
                case .NW:
                    dynamicName += "3"
                    break
                case .W:
                    dynamicName += "4"
                    break
                case .SW:
                    dynamicName += "5"
                    break
                case .SE:
                    dynamicName += "6"
                    break
                }
            }
        }

        //Check if we have the tile, if we do return it, if not we create a new one.
        let wallTileName = "surroundingWalls" + dynamicName
        let existingTile = tileWallingBoardMap!.tileSet.tileGroups.filter({$0.name == wallTileName})
        if existingTile.count != 0 {
            return existingTile.first!
        }else{
            //Create a new wall Tile node
            let baseNode = SKSpriteNode(texture: nil)
            baseNode.size = CGSize(width: 66, height: 70)
            baseNode.anchorPoint = CGPoint(x: 0.0, y: 0.0)
            baseNode.color = UIColor.clear
            baseNode.zPosition = 20

            let playerColor = UIColor.black
            //We passed a set of directions into this funciton which show which directions have an adjacent tile
            //Then we iterate through an array containing all possible directions, and check if the passed directions
            // are missing any.
            for direction in allDirections {
                if directions.contains(direction) == false {
                    // A missing direction means that there are no adjacent tiles there and therefore we need to create a wall.
                    let colorBlendFactorValue:CGFloat = 0.25
                    switch direction{
                    case .E:
                        let wallNode = SKSpriteNode(texture: self.tileWallingTextures!.rightWall)
                        wallNode.colorBlendFactor = colorBlendFactorValue
                        wallNode.color = playerColor
                        wallNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                        wallNode.position = CGPoint(x: 59, y: 40)
                        baseNode.addChild(wallNode)
                        break
                    case .NE:
                        let wallNode = SKSpriteNode(texture: self.tileWallingTextures!.upperRightWall)
                        wallNode.colorBlendFactor = colorBlendFactorValue
                        wallNode.color = playerColor
                        wallNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                        wallNode.position = CGPoint(x: 47, y: 62)
                        baseNode.addChild(wallNode)
                        break
                    case .NW:
                        let wallNode = SKSpriteNode(texture: self.tileWallingTextures!.upperLeftWall)
                        wallNode.colorBlendFactor = colorBlendFactorValue
                        wallNode.color = playerColor
                        wallNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                        wallNode.position = CGPoint(x: 19, y: 62)
                        baseNode.addChild(wallNode)
                        break
                    case .W:
                        let wallNode = SKSpriteNode(texture: self.tileWallingTextures!.leftWall)
                        wallNode.colorBlendFactor = colorBlendFactorValue
                        wallNode.color = playerColor
                        wallNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                        wallNode.position = CGPoint(x: 7, y: 40)
                        baseNode.addChild(wallNode)
                        break
                    case .SW:
                        let wallNode = SKSpriteNode(texture: self.tileWallingTextures!.lowerLeftWall)
                        wallNode.colorBlendFactor = colorBlendFactorValue
                        wallNode.color = playerColor
                        wallNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                        wallNode.position = CGPoint(x: 19, y: 18)
                        baseNode.addChild(wallNode)
                        break
                    case .SE:
                        let wallNode = SKSpriteNode(texture: self.tileWallingTextures!.lowerRightWall)
                        wallNode.colorBlendFactor = colorBlendFactorValue
                        wallNode.color = playerColor
                        wallNode.anchorPoint = CGPoint(x: 0.5, y: 0.5)
                        wallNode.position = CGPoint(x: 47, y: 18)
                        baseNode.addChild(wallNode)
                        break
                    }
                }
            }
            if let tileTexture = (mainBoardMap!.scene!.view)!.texture(from: baseNode) {
                let newGroup = SKTileGroup(tileDefinition: SKTileDefinition(texture: tileTexture))
                newGroup.name = wallTileName
                tileWallingBoardMap!.tileSet.tileGroups.append(newGroup)
                return newGroup
            }
        }
        print("FATAL ERROR \(#function) fell through all conditions")
        return nil
    }

    //Draws a walled border around a player's tiles. This is purely a cosmetic effect but helps show a border and give a sense
    // of groupings
    func updateTileWalls(for players: [Player]?){
        //Needed to make sure the adjacency is not nil
        var playerList:[Player] = []
        if self.gameModel == nil && players == nil{
            //On game startup the game model has not been created yet so we take the scene players initialized
            playerList = (self.mainBoardMap!.scene as! GameScene).gamePlayers!
        }else if self.gameModel != nil && players == nil {
            //If the game model is initialized and we are not passed a set of players then we use the full set from the gamemodel
            playerList = self.gameModel!.players! as! [Player]
        }else{
            //If we pass the list of players then we only update value for those players. Since only two players tiles
            // could possibly change during one move, then this should at most ever be 2 instead of the previous 8.
            playerList = players!
        }

        self.gameModel!.findAdjacentGroups(for: playerList)

        for player in playerList {
            for tile in player.crown_Locations! {
                let adjacency = self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileAdjacencyMatrix!
                if let tileGroup = createTileGroupOfWalls(for: adjacency, player: player) {
                    tileWallingBoardMap!.setTileGroup(tileGroup, forColumn: Int(tile.x), row: Int(tile.y))
                }
            }
            for tile in player.level1_Locations! {
                let adjacency = self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileAdjacencyMatrix!
                if let tileGroup = createTileGroupOfWalls(for: adjacency, player: player) {
                    tileWallingBoardMap!.setTileGroup(tileGroup, forColumn: Int(tile.x), row: Int(tile.y))
                }
            }
            for tile in player.level2_Locations! {
                let adjacency = self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileAdjacencyMatrix!
                if let tileGroup = createTileGroupOfWalls(for: adjacency, player: player) {
                    tileWallingBoardMap!.setTileGroup(tileGroup, forColumn: Int(tile.x), row: Int(tile.y))
                }
            }
            for tile in player.level3_Locations! {
                let adjacency = self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileAdjacencyMatrix!
                if let tileGroup = createTileGroupOfWalls(for: adjacency, player: player) {
                    tileWallingBoardMap!.setTileGroup(tileGroup, forColumn: Int(tile.x), row: Int(tile.y))
                }
            }
            for tile in player.counter_Locations! {
                let adjacency = self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileAdjacencyMatrix!
                if let tileGroup = createTileGroupOfWalls(for: adjacency, player: player) {
                    tileWallingBoardMap!.setTileGroup(tileGroup, forColumn: Int(tile.x), row: Int(tile.y))
                }
            }
        }

        resetTileWallLayer()
    }

    //Because of some strange behavior where certain wall tiles would persist after a group is surrounded, we simply clear
    // the whole wall layer before we update using the updateTileWalls().
    func resetTileWallLayer(){
        for row in 0..<tileWallingBoardMap!.numberOfRows {
            for col in 0..<tileWallingBoardMap!.numberOfColumns {
                if self.gameModel!.gameMapModel![row][col].tileType != .empty{
                    if self.gameModel!.gameMapModel![row][col].owningPlayer == nil{
                        tileWallingBoardMap!.setTileGroup(nil, forColumn: Int(col), row: Int(row))
                    }
                }
            }
        }
    }

    func debugShowTileLayerInfo(for tile: CGPoint){
        if mainBoardMap!.tileGroup(atColumn: Int(tile.x), row: Int(tile.y)) != nil {
            if mainBoardMap!.tileGroup(atColumn: Int(tile.x), row: Int(tile.y)) != nil{
                if mainBoardMap!.tileGroup(atColumn: Int(tile.x), row: Int(tile.y))!.name != nil {
                    print("tileName: \(mainBoardMap!.tileGroup(atColumn: Int(tile.x), row: Int(tile.y))!.name!)")

                    if self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].owningPlayer != nil {
                        print("modelPlayerName: Player\(self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].owningPlayer!.playerId)")
                    }
                }
            }
            let adjacencyMatrix = self.gameModel!.gameMapModel![Int(tile.y)][Int(tile.x)].tileAdjacencyMatrix!
            print("tile:\(tile) : \(adjacencyMatrix)")


            if let tilegroup = tileWallingBoardMap!.tileGroup(atColumn: Int(tile.x), row: Int(tile.y)){
                if tilegroup.name != nil {
                    print("Wall_zposition: \(self.tileWallingBoardMap!.zPosition)")
                    print("Map_zposition: \(self.mainBoardMap!.zPosition)")
                    print("tilegroup: \(tilegroup.name!)")
                }
            }
        }
    }

    func printWallTileDebug(){
        var outputString:String = ""
        if tileWallingBoardMap != nil {
            for row in 0..<tileWallingBoardMap!.numberOfRows {
                for col in 0..<tileWallingBoardMap!.numberOfColumns{
                    let rowReal = tileWallingBoardMap!.numberOfRows - row - 1
                    if col % tileWallingBoardMap!.numberOfColumns == 0 {
                        outputString += "\n"
                    }
                    if tileWallingBoardMap!.tileGroup(atColumn: col, row: rowReal) != nil {
                        outputString += "[X]"
                    }else{
                        outputString += "[ ]"
                    }
                }
            }
        }
        print(outputString)
    }

    func printWallGroupsDebug(){
        if tileWallingBoardMap != nil {
            for group in tileWallingBoardMap!.tileSet.tileGroups  {
                print(group.name!)
            }
        }
    }
}

